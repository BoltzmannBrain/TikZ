pragma options "--bnd-unroll-amnt 3 --bnd-arr1d-size 3 --bnd-arr-size 3";

#define SHAPEVARIABLES int shapeIdentity, int cx, int cy, int lx1, int ly1, int lx2, int ly2, int rx1, int ry1, int rx2, int ry2
#define SHAPEARGUMENTS shapeIdentity,cx,cy,lx1,ly1,lx2,ly2,rx1,ry1,rx2,ry2
#define CIRCLE 0
#define LINE 1
#define RECTANGLE 2

// Which figure we are trying to explain
//#define CIRCLEGRID
#define LADDER


int [n + 1] push([int n], int [n] environment, int j) {
  int [n + 1] ep = environment;
  ep[n] = j;
  return ep;
}


#define _c(x,y) (shapeIdentity == CIRCLE && cx == x && cy == y)
#define _l(x1,y1,x2,y2) (shapeIdentity == LINE && x1 == lx1 && y1 == ly1 && x2 == lx2 && y2 == ly2)
#define _r(x1,y1,x2,y2) (shapeIdentity == RECTANGLE && x1 == rx1 && y1 == ry1 && x2 == rx2 && y2 == ry2)
bit renderSpecification(SHAPEVARIABLES) {
  assume shapeIdentity == CIRCLE || shapeIdentity == LINE || shapeIdentity == RECTANGLE;
#ifdef CIRCLEGRID
  return
    _c(1, 3) ||
    _c(1, 5) ||
    _c(1, 7) ||
    _c(2, 3) ||
    _c(2, 5) ||
    _c(2, 7) ||
    _c(3, 3) ||
    _c(3, 5) ||
    _c(3, 7);
#endif
#ifdef LADDER
  return
    // ladder edges
    _l(1,1,1,5) ||
    _l(3,1,3,5) ||
    // ladder rungs
    _l(1,2,3,2) ||
    _l(1,3,3,3) ||
    _l(1,4,3,4);
#endif
}

generator int expression([int n], int[n] environment, ref int cost) {
  cost = 1;
  return {| ??(4) | ??(3)*environment[??] + ??(4) |};
}

generator bit program([int n], SHAPEVARIABLES , int[n] environment, int d, ref int cost){
  assert d > 0;
  bit hit = 0;
  if (??) {
    int loop_bound_cost,loop_body_cost;
    int loop_bound = expression(environment,loop_bound_cost);
    for (int j = 0; j < loop_bound; j++) {
      hit = hit || program(SHAPEARGUMENTS,push(environment,j),d - 1, loop_body_cost);
    }
    cost = loop_body_cost + loop_bound_cost;
    return hit;
  } else if (??) {
    cost = 0;
    int xc,yc;
    repeat(??){
      int x = expression(environment, xc);
      int y = expression(environment, yc);
      cost += (xc + yc);
      bit newHit;
      if (??) { // draw a circle
	newHit = _c(x,y);
      } else {  // draw a line or rectangle
	int x2 = expression(environment, xc);
	int y2 = expression(environment, yc);
	cost += (xc + yc);
	if (??) { // draw a line
	  newHit = _l(x,y,x2,y2);
	} else { // draw a rectangle
	  newHit = _r(x,y,x2,y2);
	}
      }
      hit = hit || newHit;
    }
    return hit;
  } else {
    assert 0;
    int variable_cost,body_cost;
    int variable_value = expression(environment,variable_cost);
    bit body_value = program(SHAPEARGUMENTS,push(environment,variable_value),d - 1,body_cost);
    cost = variable_cost + body_cost;
    return body_value;
  }
}

bit render(SHAPEVARIABLES) implements renderSpecification{
  assume shapeIdentity == CIRCLE || shapeIdentity == LINE || shapeIdentity == RECTANGLE;
  int cost;
  bit inScene = program(SHAPEARGUMENTS,{},3,cost);
  minimize(cost);
  return inScene;
}
