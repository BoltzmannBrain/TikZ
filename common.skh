

#define SHAPEVARIABLES int shapeIdentity, int cx, int cy, int lx1, int ly1, int lx2, int ly2, bit dashed, bit arrow, int rx1, int ry1, int rx2, int ry2
#define SHAPEARGUMENTS shapeIdentity,cx,cy,lx1,ly1,lx2,ly2,dashed,arrow,rx1,ry1,rx2,ry2
#define CIRCLE 0
#define LINE 1
#define RECTANGLE 2
#define LOOP 3
#define REFLECT 4

int [n + 1] push([int n], int [n] environment, int j) {
  int [n + 1] ep = environment;
  ep[n] = j;
  return ep;
}


#define _c(x,y) (shapeIdentity == CIRCLE && cx == x && cy == y)
#define _l(x1,y1,x2,y2,d,a) (shapeIdentity == LINE && x1 == lx1 && y1 == ly1 && x2 == lx2 && y2 == ly2 && d == dashed && a == arrow)
#define _r(x1,y1,x2,y2) (shapeIdentity == RECTANGLE && x1 == rx1 && y1 == ry1 && x2 == rx2 && y2 == ry2)

generator int number() { return {| 0 (+|-) ?? |}; }
generator int expression([int n], int[n] environment, ref int cost) {
  cost = 0;
  if (??) return ??;
  return number() * {| environment[0] | environment[1] |} + number();
}

// blocks are sequences of commands; can also introduce local variables.
generator bit block([int n], SHAPEVARIABLES , int[n] environment, int d, ref int cost){
  assert d > 0;
  
  cost = 0;
  bit hit = 0;
  int identity = 0;
  bit newHit;
  int newCost,newIdentity;

  //  return _c(1,5) || _c(4,3) || _c(4,5) || _c(7,1) || _c(7,5) || _c(7,3);
  /* for (int j = 0; j < 3; j++) { */
  /*   for (int k = 0; k < j + 1; k++) { */
  /*     hit = hit || primitive(SHAPEARGUMENTS, {j,k}, d, newCost, newIdentity); */
  /*     /\* hit = hit || _c((j-1)*3 + 1, *\/ */
  /*     /\* 		      5 - (k-1)*2); *\/ */
  /*     cost = 0; */
  /*   } */
  /* } */
  /* return hit; */
  
  repeat(??) {
    newHit = primitive(SHAPEARGUMENTS, environment, d, newCost, newIdentity);
    assert newIdentity >= identity;
    identity = newIdentity;
    cost += newCost;
    hit = hit || newHit;
  }
  
  if (??) {
    hit = hit || iterator(SHAPEARGUMENTS, environment, d, newCost, newIdentity);
    cost += newCost;
  }
  
  if (??) {
    hit = hit || reflection(SHAPEARGUMENTS, environment, d, newCost, newIdentity);
    cost += newCost;
  }
  return hit;
}

generator bit iterator([int n], SHAPEVARIABLES , int[n] environment, int d, ref int cost, ref int identity) {
  assert d > 0;
  bit hit = 0;
  identity = LOOP;
    
  int loop_bound_cost = 1,loop_body_cost;
  int _;
  int loop_bound = expression(environment, _);
  for (int j = 0; j < loop_bound; j++) {
    hit = hit || block(SHAPEARGUMENTS,push(environment,j),d - 1, loop_body_cost);
  }
  cost = loop_body_cost + loop_bound_cost + 1;
  return hit;
}

generator bit primitive([int n], SHAPEVARIABLES , int[n] environment, int d, ref int cost, ref int identity) {
  assert d > 0;
  
  bit hit = 0;
  cost = 1;
  int xc,yc;
  int x = expression(environment, xc);
  int y = expression(environment, yc);
  cost += (xc + yc);
  if (??) { // draw a circle
    assert HASCIRCLES;
    identity = CIRCLE;
    hit = _c(x,y);
  } else {  // draw a line or rectangle
    int x2 = expression(environment, xc);
    int y2 = expression(environment, yc);
    cost += (xc + yc);
    if (??) {
      assert HASLINES;
      bit da = ??;
      if (!HASSOLID) da = 1; // we don't have anything that is solid so it must be forced to be --
      if (!HASDASHED) da = 0;// ditto
      bit ar = ??;
      if (!HASARROW) ar = 0;
      if (!HASNOARROW) ar = 1;
      hit = _l(x,y,x2,y2,da,ar);
      identity = LINE;
    } else {
      assert HASRECTANGLES;
      identity = RECTANGLE;
      hit = _r(x,y,x2,y2);
    }
  }
  return hit;
}

generator bit reflection([int n], SHAPEVARIABLES , int[n] environment, int d, ref int cost, ref int identity) {
  assert d > 0;
  bit hit = 0;
  
  identity = REFLECT;
  int yr = ??; // y axis of reflection, multiplied by 2
  int xr = ??;
  assert yr == 0 || xr == 0;
  assert !(yr == 0 && xr == 0);
  int reflection_cost;
	
  // loop wrapper around the generator to make it only be called once
  for (int reflectionIndex = 0; reflectionIndex < 2; reflectionIndex++) {
    if (reflectionIndex == 1) {
      // Reflected case

      // reflection of a point is easy
      cy = yr == 0 ? cy : yr - (cy - 0);
      cx = xr == 0 ? cx : xr - (cx - 0);

      int rectangleHeight = ry2 - ry1;
      int rectangleWidth = rx2 - rx1;
      ry1 = yr == 0 ? ry1 : yr - (ry1 - 0) - rectangleHeight;
      ry2 = yr == 0 ? ry2 : yr - (ry2 - 0) + rectangleHeight;
      rx1 = xr == 0 ? rx1 : xr - (rx1 - 0) - rectangleWidth;
      rx2 = xr == 0 ? rx2 : xr - (rx2 - 0) + rectangleWidth;

      if (arrow) { // arrow implies that there is no canonical orientation
	ly1 = yr == 0 ? ly1 : yr - (ly1 - 0);
	ly2 = yr == 0 ? ly2 : yr - (ly2 - 0);
	lx1 = xr  == 0? lx1 : xr - (lx1 - 0);
	lx2 = xr == 0 ? lx2 : xr - (lx2 - 0);
      } else { // reflect while preserving canonical orientation
	int _ly1 = ly1;
	int _ly2 = ly2;
	int _lx1 = lx1;
	int _lx2 = lx2;
	  
	if (lx2 == lx1) { // vertical line: canonical determined by y
	  ly1 = yr == 0 ? ly1 : yr - (_ly2 - 0);
	  ly2 = yr == 0 ? ly2 : yr - (_ly1 - 0);
	} else { // arbitrary line: canonical determined by x
	  ly1 = yr == 0 ? _ly2 : yr - (ly1 - 0);
	  ly2 = yr == 0 ? _ly1 : yr - (ly2 - 0);
	}
	lx1 = xr == 0 ? lx1 : xr - (_lx2 - 0);
	lx2 = xr == 0 ? lx2 : xr - (_lx1 - 0);
      }
    }
    hit = hit || block(SHAPEARGUMENTS,environment,d - 1, reflection_cost);
  }

  cost = reflection_cost + 1;
  return hit;
}


bit render(SHAPEVARIABLES) implements renderSpecification{
  assume shapeIdentity == CIRCLE || shapeIdentity == LINE || shapeIdentity == RECTANGLE;
  if (!HASCIRCLES) assume shapeIdentity != CIRCLE;
  if (!HASRECTANGLES) assume shapeIdentity != RECTANGLE;
  if (!HASLINES) assume shapeIdentity != LINE;
  else {
    if (!HASSOLID) assume dashed;
    if (!HASDASHED) assume !dashed;
    if (!HASARROW) assume !arrow;
    if (!HASNOARROW) assume arrow;
  }
  int cost;
  bit inScene = block(SHAPEARGUMENTS,{},3,cost);
  minimize(cost);
  return inScene;
}
